---
title: LeetCode 刷题小记 011-030
categories:
  - LeetCode主站刷题小记
tags:
  - 算法
  - 数据结构
toc: true
date: 2021-05-18 09:21:29
---

[//]: # (下一行开始到<!--more-->为引文部分，引文会显示在预览中)
力扣11-30题笔记。
<!--more-->
<script id="__bs_script__">//<![CDATA[
    document.write("<script async src='http://HOST:3000/browser-sync/browser-sync-client.js?v=2.26.14'><\/script>".replace("HOST", location.hostname));
//]]></script>

[//]: # (下一行开始为正文)

### 11. [盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water)（中等）
>给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

#### 思路：
本质上就是求n块板子两两配对，它们之间的长度和距离所围成的矩形面积。如果暴力解，每块板子都与剩下的n-1块板子配对计算一次面积，也不是不行，但是复杂度为O(n²)，太笨了。
简化问题，首先面积 = 距离 \* 高度，距离好办，我们一开始分别选择两侧的板子就能保证距离最远。高度呢，那就逐渐缩短距离，以距离换高度。
那么从哪边开始缩呢，根据短板原理，需要先改变较低的一边，否则水位只可能下降（另一侧变得比这一侧还要矮）或者持平（另一侧变高或者不变）。所以确定好距离收缩的规则，从两侧向中间收缩，每次收缩求出面积取最大值即可。
时间复杂度：O(n)
空间复杂度：O(1)

#### 实现：
```java
    public int maxArea(int[] height) {
        int n = height.length;
        int left = 0;
        int right = n - 1;
        int ans = 0;
        while (left < right) {
            int leftHeight = height[left];
            int rightHeight = height[right];
            ans = Integer.max(ans, Integer.min(leftHeight, rightHeight) * (right - left));
            if (leftHeight <= rightHeight) {
                left++;
            } else {
                right--;
            }
        }
        return ans;
    }
```

### 12. [整数转罗马数字](https://leetcode-cn.com/problems/integer-to-roman)（中等）
>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。
>
字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。
>
通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：
>
>* I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
>* X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
>* C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
>给你一个整数，将其转为罗马数字。
>
示例 1:
>
输入: num = 3
输出: "III"

#### 思路：
这题比较无聊，就是对应9, 4, 5几个特殊数码进行编码，你要用字符串数组、哈希表、if-else 或者 switch来存储对应的编码都行，想清楚就没什么难度。代码省略。
时间复杂度：O(1)
空间复杂度：O(1)

### 13.[罗马数字转整数](https://leetcode-cn.com/problems/roman-to-integer)（简单）
>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。
>
示例 1:
>
输入: "III"
输出: 3

#### 思路：
这题其实可以做得比上一题巧妙，不懂为什么上题中等这题却是简单。首先转换思路比较直白，读入字符串，数值相应增加，那么跟前一题一样，需要先用个表之类的东西存储一下对应关系。难点在于，4和9的数码对应的字符串含有减法（如IX是 10 - 1 = 9，即后面的大数减去前面的小数）。
注意到，减法只会出现在大数前的小数，也就是减法永远出现在数字5,10前面的数字1处。而罗马字符整体上是从大到小显示的，一旦出现『小大』组合，便是小数变号。那么我们将字符串倒过来看，是不是就意味着，整体上是从小到大排列，一旦有『大小』组合，便是小数变号。只要此时在大数出现的时候，作一个负号标记，那么该大数往后的小数就一定需要加负号。（如MCMXCIV，倒序是VICXMCM，V是5，那么之后的I（1）就是负数，C是100，那么之后的X（10）就是负数，依此类推）
当然字符串逆序需要多一点点额外的开销，整体上原理跟官方题解没什么区别。
时间复杂度：O(1)
空间复杂度：O(1)

####实现：
```java
    public int romanToInt(String s) {
        StringBuilder sb = new StringBuilder(s);
        sb.reverse();
        String sv = sb.toString();
        
        int n = s.length();
        
        boolean minusI = false, minusX = false, minusC = false; // 负数标记
        
        int ans = 0;
        
        for (int i = 0; i < n; i++) {
            char c = sv.charAt(i);
            switch(c) { // 其中 I X C要考虑变号
                case 'I':   ans += minusI ? -1 : 1;
                            break;
                case 'V':   ans += 5;
                            minusI = true;
                            break;
                case 'X':   ans += minusX ? -10 : 10;
                            minusI = true;
                            break;
                case 'L':   ans += 50;
                            minusX = true;
                            break;
                case 'C':   ans += minusC ? -100 : 100;
                            minusX = true;
                            break;
                case 'D':   ans += 500;
                            minusC = true;
                            break;
                case 'M':   ans += 1000;
                            minusC = true;
            }
        }
        return ans;
    }
```

### 14. [最长公共前缀](https://leetcode-cn.com/problems/longest-common-prefix)（简单）
>编写一个函数来查找字符串数组中的最长公共前缀。
>
>如果不存在公共前缀，返回空字符串 ""。
>
>示例 1：
>
>输入：strs = \["flower","flow","flight"]
>输出："fl"

#### 思路：
这题的解法形象地理解就是给你并排放几根烤串，你拿一根签子垂直这些烤串，一排排把东西划下来。第一排全是豆腐，第二排全是鸡柳，第三排全是板筋，第四排，出现不一样的了有骨肉相连、有蚕蛹，那么前三排一样的部分『豆腐』、『鸡柳』、『板筋』就是所求的公共前缀。这种解法可以称之为『垂直遍历』或者『横向遍历』或者随便什么名字。
与之相对应的就是『平行遍历』，先遍历记录第一串，再遍历对比第二串，发现到不同之处就截停，丢弃余下部分，只保留相同部分，继续比对。
时间复杂度：O(nm) n是字符串个数，m是公共前缀长度。但实际上如果第一串字符串是最长的，第二种方法仍然会把它遍历完，但是多出来的部分不影响mn的数量级就是了。
空间复杂度:O(m+n)（垂直遍历） O(m)（平行遍历）

#### 实现：（用的『平行遍历』）
```java
    class ListNode {
        char key;
        ListNode next;
        ListNode(char c) {
            key = c;
            next = null;
        }
    }
    
    public String longestCommonPrefix(String[] strs) {
        int n = strs.length;
        ListNode trie = new ListNode(' ');
        
        String s = strs[0];
        int len = s.length();
        ListNode cur = trie;
        for (int i = 0; i < len; i++) {
            cur.next = new ListNode(s.charAt(i));
            cur = cur.next;
        }
        
        for (int i = 1; i < n; i++) {
            cur = trie;
            s = strs[i];
            len = s.length();
            if (len == 0) {
                trie.next = null;
            }

            for (int j = 0; j < len; j++) {
                if (cur.next != null && cur.next.key == s.charAt(j)) {
                    cur = cur.next;
                    if (j >= len - 1) {
                        cur.next = null;
                    }
                } else {
                    cur.next = null;
                    break;
                }
            }
        }

        StringBuilder sb = new StringBuilder();
        for (cur = trie.next; cur != null; cur = cur.next) {
            sb.append(cur.key);
        }

        return sb.toString();
    }
```

### 15.[三数之和](https://leetcode-cn.com/problems/3sum)（中等）
>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。
>
>注意：答案中不可以包含重复的三元组。
>
>示例 1：
>
>输入：nums = \[-1,0,1,2,-1,-4]
>输出：\[\[-1,-1,2],\[-1,0,1]]

#### 思路：
暴力解法就不谈了，很直白但是肯定超时。至少需要优化到O(n²)才可能通过。
注意到要求三元组不可重复，这种时候显然就需要排序了，不然你怎么记得自己存没存过这个答案。一开始心头一惊，一般排序要用快排，实现起来还是蛮繁琐的（要写个寻找pivot然后递归的辅助函数）。然后想起来 Arrays.sort() 这个小东西，对java的基本类型采用的是快排，于是直接拿来。
接下来看看能不能从暴力O(n³)简化到O(n²)。
上一篇笔记提过这种组合查找的题目自然而然想到用哈希表查找，把某一层O(n)的遍历降为O(1)。用一个HashSet记录一遍表中的元素，那么直接枚举前两个数，然后哈希查找第三个数。注意细节，对于 \[-4,2,3]，我们前两层得到\[-4,2，]，第三个元素用哈希搜索的话，是会得到2的，但是我们只有一个2，显然是不对的。这里如果要求 v3 > v2的话也不行，因为这样无法处理\[-4,2,2]，遂放弃哈希表。
然后看了题解才知道用双指针，感觉这里没见过这类题的话不容易想到，以后就知道这样用了，双指针跟哈希表一样也适用于这类把O(n²)遍历简化为O(n)的问题。不同的是，双指针处理可能有重复的元素更加容易一些，因为能记录下标信息，不会搞混。遍历数组得到第一个元素v1，对每一个v1之后的元素用双指针向中间查找，因为我们排过序了所以v2坐标向右增长一定是不递减的，v3一定是不递增的，所以三者之和大于0就是收缩v3下标，否则增长v2下标，直到相遇或者满足和等于0，跳出。
时间复杂度：O(n²)
空间复杂度：O(m) m是一个接近 $C_n^3$ 的数

#### 实现：
```java
    public List<List<Integer>> threeSum(int[] nums) { // 总是把题目看成threesome，捂脸
        int n = nums.length;
        Arrays.sort(nums);
        
        List<List<Integer>> ret = new LinkedList<>();
        
        for (int i = 0; i < n - 2; i++) {
            if (i == 0 || nums[i] != nums[i - 1]) {
                int k = n - 1;
                int vi = nums[i];
                for (int j = i + 1; j < k; j++) {
                    if (j == i + 1 || nums[j] != nums[j - 1]) {
                        // k-span shrinks
                        while (nums[i] + nums[j] + nums[k] > 0 && k > j + 1) {
                            k--;
                        }
                        // check and collect
                        if (vi + nums[j] + nums[k] == 0) {
                            List<Integer> ans = new LinkedList(List.of(vi, nums[j], nums[k]));
                            ret.add(ans);
                            continue;
                        } 
                    }
                }
            }
        }
        return ret;
    }
```

### 16.[最接近的三数之和](https://leetcode-cn.com/problems/3sum-closest)（中等）
> 给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。
> 
> 示例：
> 
> 输入：nums = \[-1,2,1,-4], target = 1
> 输出：2
> 解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。

#### 思路：
遍历方式跟上一道题雷同。先快速排序，再一层遍历+一层双指针。修改一下更新最佳值的条件即可，要求target和当前三数和的差值的绝对值尽可能小。
偷懒的话，可以不进行最后的指针优化（跳过重复元素），复杂度还是一样的。
时间复杂度：O(n²)
空间复杂度：O(1)

#### 实现：
```java
    public int threeSumClosest(int[] nums, int target) {
        Arrays.sort(nums);
        int n = nums.length;
        int closestSum = nums[0] + nums[1] + nums[2];
        for (int i = 0; i < n; i++) {
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            for (int j = i + 1, k = n - 1; j < k;) {
                int curSum = nums[i] + nums[j] + nums[k];
                
                if (curSum == target) {
                    return target;
                }
                    
                if (Math.abs(curSum - target) < Math.abs(closestSum - target)) {
                    closestSum = curSum;
                }
                    
                if (curSum < target) {
                    j++;
                    while (j < k && nums[j] == nums[j - 1]) {
                        j++;
                    }
                }
                else {
                    k--;
                    while (k > j && nums[k] == nums[k + 1]) {
                        k--;
                    }
                }   
            }
        }
        return closestSum;
    }
```

### 17.[电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number)（中等）
> 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的电话号码按键字母组合。答案可以按 任意顺序 返回。
> 示例 1：
> 
> 输入：digits = "23"
> 输出：\["ad","ae","af","bd","be","bf","cd","ce","cf"]

#### 思路：
要求输出的字符串其实就是按照输入的号码建树，根节点是个空串，第一个数字为2，则分出a, b, c三个子节点，第二个数字为3，每个子节点又继续各自分出d, e, f节点，依此类推，然后进行遍历，输出从根节点出发到每个叶节点的结果。由于需要我们自己建树，所以如果用DFS的话就要用回溯算法；而用BFS的话会比较直观一些，但是需要建一个辅助队列。无论哪种做法，时间复杂度都一样，DFS需要递归层数规模的栈空间，BFS需要创建队列容纳相当于所有结果，需要的堆空间比较多。
时间复杂度：O( $3^m$ \* $4^n$) 其中m是对应3个字母的数字个数（也就是2,3,4,5,6,8），n是7,9的个数
空间复杂度：BFS：O(m+n) DFS：O( $3^m$ \* $4^n$)

#### 实现（BFS）：
```java
    public List<String> letterCombinations(String digits) { // 还可使用BFS，借助队列
        List<String> combs = new LinkedList<>();
        if (digits.length() == 0) {
            return combs;
        }
        
        Map<Character, char[]> map = new HashMap<>(){{
        put('2', "abc".toCharArray());
        put('3', "def".toCharArray());
        put('4', "ghi".toCharArray());
        put('5', "jkl".toCharArray());
        put('6', "mno".toCharArray());
        put('7', "pqrs".toCharArray());
        put('8', "tuv".toCharArray());
        put('9', "wxyz".toCharArray());
    }};
        
        StringBuilder comb = new StringBuilder();
        backTrack(combs, 0, digits, comb, map);
        return combs;
    }
    
    private void backTrack(List<String> combs, int index, String digits, StringBuilder comb, Map<Character, char[]> map) {
        if (index == digits.length()) {
            combs.add(comb.toString());
        } else {
            char[] choices = map.get(digits.charAt(index));
            for (char c : choices) {
                comb.append(c);
                backTrack(combs, index + 1, digits, comb, map);
                comb.deleteCharAt(index);
            }
        }
    }
```

### 18.[题目链接-来源：力扣（LeetCode）](https://leetcode-cn.com/problems/4sum)
> 给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。
> 
> 注意：答案中不可以包含重复的四元组。
> 
>  
> 
> 示例 1：
> 
> 输入：nums = \[1,0,-1,0,-2,2], target = 0
> 输出：\[\[-2,-1,1,2],\[-2,0,0,2],\[-1,0,0,1]]

#### 思路：
经过之前的「两数之和」、「三数之和」给我们的启示，对于有序数组最内层的两数循环可以用双指针法从 O(n²) 复杂度降为 O(n)。其他层的优化不会降低复杂度，所以对于「四数之和」，复杂度最少为 O(n³）。
首先我们先将原数组排序，然后记四个数的指针从小到大依次为 l1，l2，r1，r2。我们以 l1 为基准，遍历整个数组，为了防止重复，每次更新 l1 时判断与旧值是否相等，若相等则直接跳过；其次以 d 为基准，从后往前遍历 l1 的右侧部分，同样为了防止重复，更新 r2 时需要与 l1 联合判断与前一组旧值是否完全相同；最后用双指针法，以 l2、r1 从两侧向中间遍历 l1、r2 之间的部分，同样为了防止重复，每次更新 两指针时需要将 4 个指针对应的值与旧值作比较，若完全相同则跳过。
这样遍历后即可不重复不遗漏地添加所有满足要求的数组。

时间复杂度：O(n³)
空间复杂度：O(n)

#### 实现：
```java
class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        Arrays.sort(nums);
        List<List<Integer>> ret = new LinkedList<>();
        int len = nums.length;
        int l1 = 0;
        int sum;
        int la = Integer.MIN_VALUE, lb = Integer.MIN_VALUE, lc = Integer.MAX_VALUE, ld = Integer.MAX_VALUE;
        int a, b, c, d;
        while (l1 < len - 3) {
            a = nums[l1];
            if (a == la) {
                l1++;
                continue;
            }
            int r2 = len - 1;
            while (l1 < r2 - 2) {
                d = nums[r2];
                if (a == la && d == ld) {
                    r2--;
                    continue;
                }
                int l2 = l1 + 1, r1 = r2 - 1;
                while (l2 < r1) {
                    b = nums[l2];
                    c = nums[r1];
                    if (a == la && b == lb && c == lc && d == ld) {
                        r1--;
                        l2++;
                        continue;
                    }
                    sum = a + b + c + d;
                    if (sum > target) {
                        r1--;
                    } else if (sum < target) {
                        l2++;
                    } else {
                        ret.add(Arrays.asList(a, b, c, d));
                        la = a;
                        lb = b;
                        lc = c;
                        ld = d;
                        r1--;
                        l2++;
                    }
                }
                r2--;
            }
            l1++;
        }
        
        return ret;
    }
}
```

### 19.[题目链接-来源：力扣（LeetCode）](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list)
> 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。
> 
> 进阶：你能尝试使用一趟扫描实现吗？
> 
> 示例 1：
> 
> 输入：head = \[1,2,3,4,5], n = 2
> 输出：\[1,2,3,5]

#### 思路：
我们考虑一趟扫描的思路。思考这样一种实现，我们用两个指针指向链表中的节点，这两个指针之间间隔 n 个结点，我们记更接近尾部的这个指针为 helper，更接近头部的这个指针为 handle，则当 helper 指针达到链表尾部时，handle 恰指向链表的倒数第 n + 1 个节点。
细节：链表题目为了简化判定逻辑，需要在链表头部插入一个辅助性质的「伪头结点」，方便我们简化对空表的判断逻辑。注意我们的 handle 要指向倒数第 n + 1 个节点而非倒数第 n 个节点，这样才能方便我们进行删除操作。

时间复杂度：O(n)
空间复杂度：O(1)

#### 实现：
```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode preHead = new ListNode(0);
        preHead.next = head;
        ListNode handle = preHead, helper = preHead;
        int i = 0;
        while (i < n && helper != null) {
            helper = helper.next;
            i++;
        }
        while (helper.next != null) {
            handle = handle.next;
            helper = helper.next;
        }
        handle.next = handle.next.next;
        return preHead.next;
    }
}
```

### 20.[题目链接-来源：力扣（LeetCode）](https://leetcode-cn.com/problems/valid-parentheses)
> 给定一个只包括 '('，')'，'{'，'}'，'\['，']' 的字符串 s ，判断字符串是否有效。
> 
> 有效字符串需满足：
> 
> 左括号必须用相同类型的右括号闭合。
> 左括号必须以正确的顺序闭合。
> 
> 示例 1：
> 
> 输入：s = "()"
> 输出：true

#### 思路：
括号的配对，可以用栈来解决。因为对于一个有效的括号字符串，当第一个反括号出现时，一定可以与栈顶的正括号配对，消去栈顶元素。这样不停地用反括号消去栈顶元素，当最后一个字符访问后，栈一定为空。
于是我们只要模拟这样的栈特性，当反括号出现时，就比较栈顶元素是否与其配对，若配对则消去。当遍历字符串结束后，以栈是否为空来作为判断字符串是否有效的依据。
时间复杂度：O(n)
空间复杂度：O(n)

#### 实现：
```java
class Solution {
    public boolean isValid(String s) {
        Stack<Character> pot = new Stack<>();
        int len = s.length();
        for (int i = 0; i < len; i++) {
            char c = s.charAt(i);
            if (pot.isEmpty() || !pot.peek().equals(getCounterPart(c))) {
                pot.push(c);
            } else {
                pot.pop();
            }
        }
        return pot.isEmpty();
        
    }
    
    private char getCounterPart(char c) {
        if (c == ')') {
            return '(';
        } else if( c == ']') {
            return '[';
        } else if (c == '}') {
            return '{';
        } else {
            return '\0';
        }
    }
}
```

### 21.[题目链接-来源：力扣（LeetCode）](https://leetcode-cn.com/problems/merge-two-sorted-lists)
> 将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 
> 
> 示例 1：
> 
> 输入：l1 = \[1,2,4], l2 = \[1,3,4]
> 输出：\[1,1,2,3,4,4]

#### 思路：
用两个指针指向两个链表的当前节点，取其中节点值较小者加入我们的结果链表，直到两链表均遍历完即可。
细节：用一个「伪头结点」dummy 帮我们简化对结果链表为空时的判断逻辑，当某一个链表为空时，直接将另一条链表的余下部分接入。
时间复杂度：O(n)
空间复杂度：O(n)

#### 实现：
```java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode pre = new ListNode(0);
        ListNode cur = pre;
        while (l1 != null && l2 != null) {
            if (l1.val <= l2.val) {
                cur.next = l1;
                l1 = l1.next;
            } else {
                cur.next = l2;
                l2 = l2.next;
            }
            cur = cur.next;
        }
        
        if (l1 != null) {
            cur.next = l1;
        }
        if (l2 != null) {
            cur.next = l2;
        }
        return pre.next;
    }
}
```

### 22.[题目链接-来源：力扣（LeetCode）](https://leetcode-cn.com/problems/generate-parentheses)
> 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。
> 
> 示例 1：
> 
> 输入：n = 3
> 输出：\["((()))","(()())","(())()","()(())","()()()"]

#### 思路：
这是字符串生成的问题，可以考虑 DFS + 回溯法。
我们利用 DFS 递归地遍历当前下一位所有可能的括号组合（当前至多有 2 种选择），然后用回溯法回到递归前的状态，当左右括号数等于所需的对数时，即收集结果。如此我们可以遍历每一位的括号组合。
细节：「剪枝」，即进行下一步之前，通过条件判断过滤掉一些不可能的选择，比如，右括号不能多于左括号，所以当左右括号数相等时，我们下一步只能添加左括号；否则，我们既可以添加左括号，也可右括号，依次回溯遍历即可。
时间复杂度：O(4^n/n^0.5)
空间复杂度：O(n)

#### 实现：
```java
class Solution {
    public List<String> generateParenthesis(int n) {
        int l = 0, r = 0;
        sb = new StringBuilder();
        ret = new LinkedList<>();
        helper(l, r, n);
        return ret;
    }
    private StringBuilder sb;
    private List<String> ret;
    private void helper(int l, int r, int n) {
        if (l > r && l < n) {
            for (int i = 0; i < 2; i++) {
                if (i == 0) {
                    sb.append('(');
                    helper(l + 1, r, n);
                    sb.deleteCharAt(sb.length() - 1);
                } else {
                    sb.append(')');
                    helper(l, r + 1, n);
                    sb.deleteCharAt(sb.length() - 1);
                }
            }
        } else if (l == r && l < n) {
            sb.append('(');
            helper(l + 1, r, n);
            sb.deleteCharAt(sb.length() - 1);
        } else {
            for (int i = 0; i < n - r; i++) {
                sb.append(')');
            }
            ret.add(sb.toString());
            sb.delete(sb.length() - n + r, sb.length());
        }
    }
}
```

### 23.[题目链接-来源：力扣（LeetCode）](https://leetcode-cn.com/problems/merge-k-sorted-lists)
> 给你一个链表数组，每个链表都已经按升序排列。
> 
> 请你将所有链表合并到一个升序链表中，返回合并后的链表。
> 
> 示例 1：
> 
> 输入：lists = \[\[1,4,5],\[1,3,4],\[2,6]]
> 输出：\[1,1,2,3,4,4,5,6]
> 解释：链表数组如下：
> \[
>   1->4->5,
>   1->3->4,
>   2->6
> ]
> 将它们合并到一个有序链表中得到。
> 1->1->2->3->4->4->5->6

#### 思路：
我们的思路基于「合并2个升序链表」拓展。在 k = 2 时，我们所要获取的链表节点实际上是当前节点值最小的那个节点。于是，我们只要维护一个可以方便获取到 当前活跃链表的未处理值 的最小堆即可。这个最小堆（优先级队列）能让我们以单次平均 O(logk) 的复杂度获取所需的节点。
细节：
* 我们需要提供一个比较器接口给最小堆，这个比较器需要返回两个节点中节点值较小的那一个节点。
* 另外，当我们弹出一个节点，将其加入我们的返回列表以后，我们要将它的后续节点放回最小堆当中，直到后续节点为空。
* 时刻记得我们可以用一个 dummy 节点简化链表类问题对空表的判断逻辑。
时间复杂度：O(nlogk)
空间复杂度：O(k)

#### 实现：
```java
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        Comparator<ListNode> cmp = (ListNode a, ListNode b) -> {
            if (a != null && b != null) {
                return a.val - b.val;
            } else if (a != null) {
                return a.val;
            } else if (b != null) {
                return b.val;
            } else {
                return 0;
            }
        };
        
        PriorityQueue<ListNode> pq = new PriorityQueue<>(cmp);
        ListNode dummy = new ListNode(), cur = dummy;
        for (ListNode list : lists) {
            if (list != null) {
                pq.offer(list);
            }
        }
        while (pq.size() > 1) {
            cur.next = pq.poll();
            cur = cur.next;
            if (cur.next != null) {
                pq.offer(cur.next);
            }
        }
        if (!pq.isEmpty()) {
            cur.next = pq.poll();
        }
        
        return dummy.next;
        
    }
}
```

### 24.[题目链接-来源：力扣（LeetCode）](https://leetcode-cn.com/problems/swap-nodes-in-pairs)
> 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。
> 
> 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
> 
> 示例 1：
> 
> 输入：head = \[1,2,3,4]
> 输出：\[2,1,4,3]

#### 思路：
本题是下一题「25. K 个一组翻转链表」的特例，理清本题思路有助于我们解决下一题。
此类题目有递归法和迭代法两种。递归法代码简洁，但由于递归本身需要的栈空间，空间复杂度为 O(1)，且不易理解，故采用迭代法。
首先还是用一个「哑节点」dummy 插入链表头部。直观上理解，我们可以从头到尾一对一对地依次翻转每一段节点（在本题中，一段即有 2 个节点，而在下一题种，一段有 k 个节点），事实上这样做的效率也是最高的，因为无需额外的遍历。用指针 curFront 标记当前要处理的段的起始节点，用指针 preCur 抓住该节点的前驱，用指针 curNext (对于下一题是 curEnd) 标记当前节点对的末尾（第二个）节点，用指针 rest 标记末尾节点之后的节点，也就是链表的剩余部分。
于是我们的可以很清晰地得出每次循环的处理流程，preCur 应该指向 curNext，curFront 应该指向 rest，然后当前段内部 curFront 与 curNext 反转顺序即可。进行下一轮循环前，preCur 要指向下一段的前驱，即 curFront，然后其他指针依次接力更新。当更新失败时标记为 null，这样我们的中止条件就是待处理的某个节点（可以是 curFront，或者 curNext）为 null。
最后返回 dummy.next 即可。
时间复杂度：O(n)
空间复杂度：O(1)

#### 实现：
```java
class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode dummy = new ListNode(0, head);
        ListNode preCur = dummy, curFront = dummy.next, curNext = curFront == null ? null : curFront.next;
        while (curNext != null) {
            ListNode rest = curNext.next;
            preCur.next = curNext;
            curNext.next = curFront;
            curFront.next = rest;
            
            preCur = curFront;
            curFront = rest;
            curNext = rest == null ? null : rest.next;
        }
        return dummy.next;
    }
}
```

### 25.[题目链接-来源：力扣（LeetCode）](https://leetcode-cn.com/problems/reverse-nodes-in-k-group)
> 给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。
> 
> k 是一个正整数，它的值小于或等于链表的长度。
> 
> 如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。
> 
> 进阶：
> 
> 你可以设计一个只使用常数额外空间的算法来解决此问题吗？
> 你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。
> 
> 示例 1：
> 
> 输入：head = \[1,2,3,4,5], k = 2
> 输出：\[2,1,4,3,5]

#### 思路：
此题是上一题的一般情况，我们可以沿用其框架，即对于一段长度为 k 的待处理节点，用 preCur 指向该段的前驱，用 curFront 标记本段的起始节点，然后对 preCur 之后的 k 个节点，我们提取一个 reverse() 方法单独处理对其的翻转操作，返回反转以后的头结点。由于我们要避免处理长度为 k 的段，在进行 reverse() 操作之前，我们要从 preCur 之后数出 k 个节点，若计数未满即至表尾，则表示已经无需操作，跳出循环。
每次循环末尾，我们需要更新 preCur 的信息，preCur 作为下一段节点的前驱，其应该指向当前段完成 reverse() 以后的最末节点，也就是本轮循环一开始的起始节点 curFront。
记得用 哑节点 dummy 帮助我们简化判断逻辑，完成后，返回 dummy.next即可。
时间复杂度：O(n)
空间复杂度：O(1)

#### 实现：
```java
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode dummy = new ListNode(0, head);
        ListNode preCur = dummy, curFront = preCur.next;
        PROC:
        while (curFront != null) {
            ListNode curEnd = curFront;
            for (int i = 1; i < k; i++) {
                curEnd = curEnd.next;
                if (curEnd == null) {
                    break PROC;
                }
            }
            preCur.next = reverse(curFront, k);
            
            preCur = curFront;
            curFront = curFront.next;
        }
        return dummy.next;
    }
    private ListNode reverse(ListNode head, int k) {
        ListNode cur = head, pre = null;
        while (k > 0) {
            ListNode rest = cur.next;
            cur.next = pre;
            pre = cur;
            cur = rest;
            k--;
        }
        head.next = cur;
        return pre;
    }
}
```

### 26.[题目链接-来源：力扣（LeetCode）](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array)
> 给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。
> 
> 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。
> 
> 示例 1：
> 
> 输入：nums = \[1,1,2]
> 输出：2, nums = \[1,2]
> 解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。

#### 思路：
我们可以跳跃地处理数组的数据。容易想象，对于处理完毕的结果数组，在有效长度（即返回值对应的长度）内，每一个元素的值都不相等。我们只要跳跃地取出这些值，依次复制到数组头部，待跳跃超出了数组实际长度后停止即可。
由于数组有序，容易想到用二分法来定位待操作的元素。
我们可以写一个辅助函数 findNextEle(target)，这个函数的作用是返回 「数组中大于 target 的第一个元素」。对于数组中的第一个元素，我们令 target = nums\[0]，调用 findNextEle() 即可找到下一个要复制的元素所在的位置，也就是我们跳转的目标。于是我们依次在数组的第 i 位，放下 第 findNextEle(num\[i]) 个元素，即可完成目标。
于是我们只要实现这个 findNextEle() 函数即可。主体结构是二分法，在数组中，用两个指针 l 和 r 指明查找的边界，比较边界中点 mid 处指向的值，若小于等于待查找元素 target，则右移 l，否则左移 r，当 l 越过 r 时返回 l 的值即可。

时间复杂度：O(n) 当数组只有很少的元素重复时，达到最坏复杂度 O(n)；但如果数组重复的元素很多，此方法可以达到 O(logn)的效率。
空间复杂度：O(1)

#### 实现：
```java
class Solution {
    public int removeDuplicates(int[] nums) {
        int len = nums.length;
        if (len == 0) {
            return 0;
        }
        
        int count = 1;
        
        for (int i = 0; i < len - 1;) {
            int target = nums[i];
            i = findNextEle(nums, i, target);
            if (i < len) {
                nums[count++] = nums[i];
            }
        }
        return count;
    }
    
    private int findNextEle(int[] arr, int start, int target) {
        int l = start, r = arr.length - 1;
        while (l <= r) {
            int mid = l + ((r - l) >> 1);
            if (arr[mid] <= target) {
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }
        return l;
    }
    
}
```

### 27.[题目链接-来源：力扣（LeetCode）](https://leetcode-cn.com/problems/remove-element)
> 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。
> 
> 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。
> 
> 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
> 
> 输入：nums = \[3,2,2,3], val = 3
> 输出：2, nums = \[2,2]
> 解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = \[2,2,3,3] 或 nums = \[2,2,0,0]，也会被视作正确答案。

#### 思路：
注意到元素的顺序可以改变，为了最大限度减少访存次数，我们不直接删除数组元素，而是将丢弃的元素交换到数组末尾。
同时为了尽可能降低复杂度，我们采用双指针，一个前指针 i 指向待处理的元素，从前往后遍历，另一个后指针 len 指向数组尾部元素，从后往前遍历，跳过我们需要删除的值（跳过的元素值均等于 val，表示我们放弃不用）。这样只需 n 次访问，最终返回 len 的值即可。
时间复杂度：O(n)
空间复杂度：O(1)

#### 实现：
```java
class Solution {
    public int removeElement(int[] nums, int val) {
        len = nums.length;
        for (int i = 0; i < len; i++) {
            while (len > 0 && nums[len - 1] == val) {
                len--;
            }
            if (i >= len - 1) {
                break;
            }
            if (nums[i] == val) {
                swap(nums, i, --len);
            }
        }
        return len;
    }
    private int len;
    
    private void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
}
```

### 28.[题目链接-来源：力扣（LeetCode）](https://leetcode-cn.com/problems/implement-strstr)
> 实现 strStr() 函数。
> 
> 给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。
> 
> 说明：
> 
> 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。
> 
> 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。
> 
> 示例 1：
> 
> 输入：haystack = "hello", needle = "ll"
> 输出：2

#### 思路：
此题是 KMP 算法的典型应用。记 haystack 的长度为 h，needle 的长度为 n，则暴力解法可以在 O(hn)的复杂度内完成查找（每次在 haystack 中移动到新的一位时，最坏情况下要从此处开始依次与 needle 作比较）。
考虑优化解法。我们的问题是，是否每次匹配失败后，needle 的指针都要回退到开头？能否经过一些处理，减少指针跳转的次数？答案就是 KMP 算法。
对于形如 "abcabd" 的 needle 串，我们考虑暴力法和 KMP 法的指针跳转情况。对于暴力法，一旦我们匹配失败，指针就要跳转到开头处进行比较；而对于 KMP法，当我们的指针指向 'd' 所在的位置时，匹配失败了，则我们（希望）跳转到 'c' 所在的位置进行比较，这样我们可以省下一半的时间。我们现在来确定这个跳转规则。
我们可以这样考虑，记 "abcabd" 的指针为 i，对应的指针序号为 012345，我们维护一个与 needle 长度一样跳转表 jump，记录每一位访问失败时指针应当跳转向何处。对于数组中我们的跳转目的，其指针记为 j。i、j均从 0 开始。
* 为了兼容空串，我们将 needle 前方拼接上一个不会出现的字符，这里我选择空格 ' '，方便我们后续处理。
* 对于首字符 i = 1，匹配失败后应当回到开头，故我们可以定义 jump\[1] = 0。
* 对于 i >= 2，由于 needle\[i] != needle\[j]，即我们并不能找到合适的重用信息，我们希望 j 往 jump\[j] 跳转，看能否找到合适的 needle\[j] = needle\[i] 可以让我们复用，直到 j = 0 若还未找到，我们认为不存在，于是默认跳转为 0，否则，应当设定 jump\[i] = j。
* 对于 i = 4，我们发现 needle\[i] = needle\[j]，即出现了可以复用的情况，即可维护当前 jump\[i] = j + 1，同时让 j 指向下个位置。
经过这样预处理之后的 jump 数组，即可用来帮助我们遍历主字符串 haystack。遍历规则类似我们生成 jump 时的规则，当指向 needle 的指针越界，则表示我们已经找到了合适的串，返回该串的起点坐标即可。
时间复杂度：O(h + n)
空间复杂度：O(n)

#### 实现：
```java
class Solution {
    public int strStr(String haystack, String needle) {
        int lenH = haystack.length(), lenN = needle.length();
        if (lenN == 0) {
            return 0;
        }
        String h = " " + haystack, n = " " + needle;
        
        // Set jump table
        int[] jump = new int[lenN + 1];
        for (int i = 2, j = 0; i <= lenN; i++) {
            char cI = n.charAt(i);
            while (j > 0 && n.charAt(j + 1) != cI) {
                j = jump[j];
            }
            if (cI == n.charAt(j + 1)) {
                j++;
            }
            jump[i] = j;
        }
        
        // KMP body
        for (int i = 1, j = 0; i <= lenH; i++) {
            char cI = h.charAt(i);
            while (j > 0 && n.charAt(j + 1) != cI) {
                j = jump[j];
            }
            if (cI == n.charAt(j + 1)) {
                j++;
            }
            if (j == lenN) {
                return i - j;
            }
        }
        return - 1;
    }
}
```

### 29.[题目链接-来源：力扣（LeetCode）](https://leetcode-cn.com/problems/divide-two-integers)
> 给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。
> 
> 返回被除数 dividend 除以除数 divisor 得到的商。
> 
> 整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2
> 
> 示例 1:
> 
> 输入: dividend = 10, divisor = 3
> 输出: 3
> 解释: 10/3 = truncate(3.33333..) = truncate(3) = 3

#### 思路：
题目要求不能用乘除法，也就是几乎要我们实现一个有符号整数除法器。
我们可以参考竖式计算的思路来构造这个除法器。
* 在竖式中，我们固定被除数 dividend，依次从高到低遍历其每一位。
* 在每一轮遍历中，我们对除数 divisor 进行左移操作，直到移位后的结果「恰好」小于等于 dividend （「恰好」的意思是，若该结果继续左移 1 位，则结果会大于 dividend）。
* 用被除数 dividend 减去这个移位结果，得到的数字作为新的 dividend 进行下一轮循环，直到 dividend 小于 divisor 而停止。
以上操作默认两个操作数的符号均为正数。实际运算中，我们会碰到 被除数 和 除数 符号不一致的情况，可以记录其原始符号，转换符号一致后进行运算，最后再补回符号。
另外，本题假设环境只存储 32 位整数，为了防止结果溢出，我们可以统一把 被除数 和 除数 转换为 **负数** （因为负数的表数范围比正数大 1，所以转成负数时不会溢出）， 此时，对于前述循环，其涉及到的 不等关系 全都要反向（即「小于」应变为「大于」，以此类推）。
细节，题目要求特殊值，除法结果溢出（其实只有一种情况，就是 -2^31 / -1，没有对应的正数）要返回 2^31 - 1 ，也就是最大的正数，因此单独处理即可。
时间复杂度：O(1)
空间复杂度：O(1)

#### 实现：
```java
class Solution {
    public int divide(int dividend, int divisor) {
        if (dividend == Integer.MIN_VALUE && divisor == -1) {
            return Integer.MAX_VALUE;
        }
        boolean nagative = false;
        if (dividend > 0) {
            dividend = 0 - dividend;
            nagative = !nagative;
        }
        if (divisor > 0) {
            divisor = 0 - divisor;
            nagative = !nagative;
        }
        int quotient = 0;
        while (dividend <= divisor) {
            div d = divOneTime(dividend, divisor);
            quotient += d.quo;
            dividend -= d.prod;
        }
        
        if (nagative) {
            quotient = 0 - quotient;
        }
        return quotient;
    }
    private class div {
        int quo;
        int prod;
        public div(int q, int p) {
            quo = q;
            prod = p;
        }
    }
    
    private div divOneTime(int d, int r) {
        int dup = r << 1;
        int quo = 1;
        while (dup < 0 && d <= dup) {
            dup <<= 1;
            quo <<= 1;
            r <<= 1;
        }
        return new div(quo, r);
    }
}
```

### 30.[题目链接-来源：力扣（LeetCode）](https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words)
> 给定一个字符串 s 和一些 长度相同 的单词 words 。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。
> 
> 注意子串要与 words 中的单词完全匹配，中间不能有其他字符 ，但不需要考虑 words 中单词串联的顺序。
> 
> 示例 1：
> 
> 输入：s = "barfoothefoobarman", words = \["foo","bar"]
> 输出：\[0,9]
> 解释：
> 从索引 0 和 9 开始的子串分别是 "barfoo" 和 "foobar" 。
> 输出的顺序不重要, \[9,0] 也是有效答案。

#### 思路：
本题可以先从暴力解着手开展思路。记 words 的单词个数为 wNum， 每个单词长度为 wLen。我们可以遍历 s 中的每一位，以之为起点开始向后查找单词，总共查找 wNum 次，每次跨越 wLen 个字符，用一个哈希表统计单词出现次数，并与 words 中的次数进行比较，若一致则可将此位加入结果列表中。
我们如何优化暴力解呢？考虑如下字符串实例 s = "wordgoodgoodgoodcestword"，words = \["word","good","best","word"]，我们以 偏移量0 为起点 得到字符串 s0 "wordgoodgoodgood"，进行统计，我们得到了 3 个 "good"，现在我们需要寻找下一个作为起点的偏移量。
* 我们的统计是以单词为单位的，对于 s0，我们希望其统计信息可以复用，那么 s1、s2、s3 由于字符的错位，是无法复用统计信息的。而对于 s4，我们可以简单地在统计信息中剔除头部的 1个 "word"，加上尾部的 1个 "best"，而不需要重新遍历中间的字符。于是我们可以将子串按照起点坐标对 wLen 的余数进行分组，这样分成了 wLen 组，同一组内的统计信息可以从前往后依次复用。
* 对于其中某一组，比如余数为 0 的组，子串 s4、s8 当中必然包含了超过 1 个的 "good"，因此这部分子串我们可以直接跳过，直接跳转到 s12 继续我们的匹配。
* 对于具体的某一串，我们有时不需要遍历整个串就能判断该串不符合条件。比如 s0，当我们统计到第 2 个 "good" 出现的时候，单词数量已经超标，即可判断该串不符合要求，跳转到 s12 继续匹配。同理，对于 s12，我们统计到 "cest" 时发现单词表中并没有这个单词，我们也能直接跳过，转到 s20 继续匹配。
具体实现中，为了在常数时间内判断出当前子串是否符合条件，我们可以先预处理一个哈希表 example，存储 words 中每个单词的个数。在子串收集单词的时候，我们用一个计数 collectedNum 来统计已经收集到的单词，同时建立一个临时哈希表 count 统计当前子串每个单词的个数信息，如果单词已存在于 example 中且个数没有超标，我们就将其计入 count 中，同时 collectedNum 步进。否则，我们认为该单词非法（可能是个数超标，也可能是单词根本不存在），我们再分别作相应的处理。
时间复杂度：O(n)
空间复杂度：O(m) m 为 words 的单词个数 wNum

#### 实现：
```java
class Solution {
    public List<Integer> findSubstring(String s, String[] words) {
        int wLen = words[0].length(), wNum = words.length, sLen = s.length();
        List<Integer> ret = new LinkedList<>();
        
        Map<String, Integer> example = new HashMap<>() {{
            for (String eachWord : words) {
                put(eachWord, getOrDefault(eachWord, 0) + 1);
            }
        }};
        
        int headBound = sLen - wLen * wNum;
        for (int i = 0; i < wLen; i++) {
            Map<String, Integer> count = new HashMap<>();
            
            int collectedNum = 0;
            for (int head = i, j = head; head <= headBound;) {
                while (collectedNum < wNum && j + wLen <= sLen) {
                    String toCollect = s.substring(j, j + wLen);
                    if (example.containsKey(toCollect)) {
                        count.put(toCollect, count.getOrDefault(toCollect, 0) + 1);
                        collectedNum++;
                        
                        int countBound = example.get(toCollect);
                        while (count.get(toCollect) > countBound) {// 当有多余重复的串出现时，删除至数量符合要求为止
                            String toDelete = s.substring(head, head + wLen);
                            head += wLen;
                            collectedNum--;
                            int value = count.get(toDelete);
                            if (value <= 1) {
                                count.remove(toDelete);
                            } else {
                                count.put(toDelete, value - 1);
                            }    
                        }
                    } else {
                        head = j + wLen;
                        count.clear();
                        collectedNum = 0;
                    }
                    j += wLen;
                }
                if (collectedNum == wNum) {
                    ret.add(head);
                }
                
                if (head <= headBound) {
                    String toDelete = s.substring(head, head + wLen);
                    int value = count.get(toDelete);
                    if (value <= 1) {
                        count.remove(toDelete);
                    } else {
                        count.put(toDelete, value - 1);
                    }
                    head += wLen;
                    collectedNum--;
                }
            }
        }
        return ret;
    }
}
```